use std::time::Duration;

use tokio::{runtime::Builder, time::sleep};

/// This example shows how to use `block_on` to wait for a background task to complete.
fn main() {
  let runtime = Builder::new_multi_thread().worker_threads(1).enable_all().build().unwrap();

  let mut handles = Vec::with_capacity(10);
  for i in 0..10 {
    handles.push(runtime.spawn(my_bg_task(i)));
  }

  // Do something time-consuming while the background tasks execute.
  std::thread::sleep(Duration::from_millis(750));
  println!("Finished time-consuming task.");

  // Wait for all of them to complete.
  for handle in handles {
    // The `spawn` method returns a `JoinHandle`. A `JoinHandle` is a future,
    // so we can wait for it using `block_on`.
    runtime.block_on(handle).unwrap();
  }
}

async fn my_bg_task(i: u64) {
  // By subtracting, the tasks with larger values of i sleep for a
  // shorter duration.
  let millis = 1000 - 50 * i;
  println!("Task {} sleeping for {} ms.", i, millis);

  sleep(Duration::from_millis(millis)).await;

  println!("Task {} stopping.", i);
}
