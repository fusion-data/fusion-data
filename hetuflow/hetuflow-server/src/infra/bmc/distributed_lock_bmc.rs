use std::time::Duration;

use fusionsql::{ModelManager, SqlError, base::DbBmc, generate_pg_bmc_common, generate_pg_bmc_filter};

use crate::model::{DistributedLockEntity, DistributedLockFilter, DistributedLockForInsert, DistributedLockForUpdate};

pub struct DistributedLockBmc;

impl DbBmc for DistributedLockBmc {
  const TABLE: &str = "distributed_lock";
  const ID_GENERATED_BY_DB: bool = false;
}

generate_pg_bmc_common!(
  Bmc: DistributedLockBmc,
  Entity: DistributedLockEntity,
  ForUpdate: DistributedLockForUpdate,
  ForInsert: DistributedLockForInsert,
);

generate_pg_bmc_filter!(
  Bmc: DistributedLockBmc,
  Entity: DistributedLockEntity,
  Filter: DistributedLockFilter,
  ForUpdate: DistributedLockForUpdate,
);

impl DistributedLockBmc {
  /// Attempt to acquire and update a distributed lock.
  ///
  /// Implements a high-frequency heartbeat + low-frequency token increment mechanism:
  /// - INSERT: token is auto-generated by bigserial
  /// - UPDATE: increment token under conditions (lock expired, node changed, or interval exceeded)
  /// - Fencing token mechanism prevents stale leader interference
  ///
  /// # Arguments
  /// - `mm`: model manager
  /// - `id`: unique lock identifier
  /// - `value`: lock holder identifier (e.g., node ID)
  /// - `ttl`: lock time-to-live
  /// - `token_increment_interval`: token increment period
  ///
  /// # Returns
  /// - `Some(entity)`: lock acquired or updated successfully
  /// - `None`: lock held by another node and not expired
  pub async fn try_acquire_or_update(
    mm: &ModelManager,
    id: &str,
    value: &str,
    ttl: &Duration,
    token_increment_interval: &Duration,
  ) -> Result<Option<DistributedLockEntity>, SqlError> {
    let sql = r#"insert into distributed_lock(id, value, locked_at, expires_at)
values ($1, $2, now(), now() + $3)
on conflict (id) do update
set value      = excluded.value,
    expires_at = excluded.expires_at,
    -- increment token when taking over lock or interval exceeds threshold
    token      = case
                   when distributed_lock.expires_at < now()
                        or distributed_lock.value <> excluded.value
                        or now() - distributed_lock.locked_at > $4
                   then distributed_lock.token + 1
                   else distributed_lock.token
                 end,
    -- update locked_at when token is incremented
    locked_at  = case
                   when distributed_lock.expires_at < now()
                        or distributed_lock.value <> excluded.value
                        or now() - distributed_lock.locked_at > $4
                   then now()
                   else distributed_lock.locked_at
                 end
where distributed_lock.expires_at < now()
   or distributed_lock.value = excluded.value
returning *"#;
    let db = mm.dbx().db_postgres()?;
    let query = sqlx::query_as::<_, DistributedLockEntity>(sql)
      .bind(id)
      .bind(value)
      .bind(ttl)
      .bind(token_increment_interval);
    let item = db.fetch_optional(query).await?;
    Ok(item)
  }

  /// Release the distributed lock.
  ///
  /// Only the lock holder (matching value) can release the lock.
  ///
  /// # Arguments
  /// - `mm`: model manager
  /// - `id`: unique lock identifier
  /// - `value`: lock holder identifier
  ///
  /// # Returns
  /// - `true`: lock released successfully
  /// - `false`: lock does not exist or not held by the current holder
  pub async fn release_leadership(mm: &ModelManager, id: &str, value: &str) -> Result<bool, SqlError> {
    let sql = r#"delete from distributed_lock where id = $1 and value = $2"#;
    let db = mm.dbx().db_postgres()?;
    let query = sqlx::query(sql).bind(id).bind(value);
    let rows_affected = db.execute(query).await?;
    Ok(rows_affected == 1)
  }

  /// Validate the safety of distributed-lock parameter configuration.
  ///
  /// Per design doc, ensure TTL > token_increment_interval; recommend TTL >= 2 * token_increment_interval.
  ///
  /// # Arguments
  /// - `ttl`: lock time-to-live
  /// - `token_increment_interval`: token increment period
  ///
  /// # Returns
  /// - `Ok(())`: configuration is safe
  /// - `Err(String)`: configuration is risky, with error message
  pub fn validate_lock_config(ttl: Duration, token_increment_interval: Duration) -> Result<(), String> {
    if ttl <= token_increment_interval {
      return Err(format!(
        "不安全的配置：TTL({:?}) 必须大于 token_increment_interval({:?})",
        ttl, token_increment_interval
      ));
    }

    if ttl < token_increment_interval * 2 {
      return Err(format!(
        "建议配置：TTL({:?}) 应该 >= 2 * token_increment_interval({:?}) 以确保围栏令牌安全",
        ttl, token_increment_interval
      ));
    }

    Ok(())
  }

  /// Get recommended distributed-lock configuration.
  ///
  /// Based on design doc, return safe parameter configuration.
  ///
  /// # Returns
  /// - `(ttl, token_increment_interval, heartbeat_interval)`: recommended configuration
  pub fn get_recommended_config() -> (Duration, Duration, Duration) {
    (
      Duration::from_secs(60), // TTL: 60 seconds
      Duration::from_secs(27), // token increment period: 27 seconds
      Duration::from_secs(17), // heartbeat frequency: 17 seconds
    )
  }
}
